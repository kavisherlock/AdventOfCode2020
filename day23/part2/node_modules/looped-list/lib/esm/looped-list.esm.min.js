class e{constructor(e,t=!1){this.value=e,this.next_item=void 0,this.prev_item=void 0,t&&(this.next_item=this,this.prev_item=this)}next(e=1){if(0===(e=Math.trunc(e)))return this;if(e<0)return this.prev(Math.abs(e));let t=this;do{t=t.next_item}while(--e);return t}prev(e=1){if(0===(e=Math.trunc(e)))return this;if(e<0)return this.next(Math.abs(e));let t=this;do{t=t.prev_item}while(--e);return t}insertNext(e){return this.next_item.prev_item=e,e.next_item=this.next_item,this.next_item=e,e.prev_item=this,e}insertPrev(e){return this.prev_item.next_item=e,e.next_item=this,e.prev_item=this.prev_item,this.prev_item=e,e}removeSelf(){return this.next_item.prev_item=this.prev_item,this.prev_item.next_item=this.next_item,this}}class t{constructor(e){if(this.head=void 0,Array.isArray(e)&&e.length){let t=e[0];if(this.setHead(t),e.length>2){for(let t=1;t<e.length;t++)this.insertNext(e[t]);this.move(1)}}else void 0!==e&&this.setHead(e)}setHead(t){return t instanceof e||void 0===t||(t=new e(t,!0)),this.head=t,this}unsetHead(){return this.setHead(void 0)}init(...e){return this.setHead(...e)}move(e=1){let t=(e=Math.trunc(e))>0?"next":"prev";return e=Math.abs(e),this.head=this.head[t](e),this}insertNext(t){return t instanceof e||(t=new e(t)),this.head=this.head.insertNext(t),this}insertPrev(t){return t instanceof e||(t=new e(t)),this.head=this.head.insertPrev(t),this}popHeadMoveNext(){let e=this.head.next_item,t=this.head.removeSelf();return this.head=e,t}popHeadMovePrev(){let e=this.head.prev_item,t=this.head.removeSelf();return this.head=e,t}length(){let e=this.head;if(!e)return 0;let t=e.next_item,i=1;for(;t!==e;)i++,t=t.next_item;return i}find(t){let i=!(t instanceof e),r=this.head;if(!r)return;let s=this.head;do{if(t===(i?s.value:s))return s;s=s.next_item}while(s!==r)}*[Symbol.iterator](){yield*this.items()}*items(){let e=this.head;if(!e)return;yield e;let t=e.next_item;for(;t!==e;)yield t,t=t.next_item}*values(){let e=this.items();for(let t of e)yield t.value}}export{t as LoopedList,e as LoopedListItem};
